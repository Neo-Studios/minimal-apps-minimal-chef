import Foundation
import UIKit

@available(iOS 18.0, *)
class AIManager {
    static let shared = AIManager()
    
    private var cache: [String: String] = [:]
    private let cacheQueue = DispatchQueue(label: "com.neostudios.minimalchef.ai.cache")
    
    private init() {}
    
    func isAIAvailable() -> Bool {
        guard #available(iOS 18.0, *) else { return false }
        
        let systemVersion = UIDevice.current.systemVersion
        if let majorVersion = Int(systemVersion.split(separator: ".").first ?? "0") {
            return majorVersion >= 18 && hasNeuralEngine()
        }
        
        return false
    }
    
    private func hasNeuralEngine() -> Bool {
        // This is a simplified check. A more robust implementation would involve
        // checking for the availability of the NeuralEngine framework and its features.
        // For now, we'll assume that any device running iOS 18.0 or later has
        // the necessary hardware.
        return true
    }
    
    func generateRecipeSuggestion(ingredients: [String]) async -> String? {
        guard isAIAvailable(), !ingredients.isEmpty else { return nil }
        
        let cacheKey = "recipe_\(ingredients.sorted().joined(separator: "_"))"
        if let cached = getCached(key: cacheKey) {
            return cached
        }
        
        let prompt = "Create a detailed recipe using the following ingredients: \(ingredients.joined(separator: ", ")). Please provide the output in JSON format with the following fields: 'name' (string), 'ingredients' (array of objects with 'name', 'quantity', and 'unit' strings), 'instructions' (array of strings), 'prepTime' (integer in minutes), 'cookTime' (integer in minutes), 'servings' (integer), and 'difficulty' (string: 'Easy', 'Medium', or 'Hard')."
        
        let result: String?
        if #available(iOS 18.0, *) {
            result = await generateWithAppleIntelligence(prompt: prompt, ingredients: ingredients)
        } else {
            result = getFallbackRecipe(ingredients: ingredients)
        }
        
        if let result = result {
            setCached(key: cacheKey, value: result)
        }
        
        return result
    }
    
    func generateShoppingList(from recipe: Recipe) async -> [String]? {
        guard isAIAvailable() else { return nil }
        
        let ingredients = recipe.ingredients.map { $0.name }
        let prompt = "Create a shopping list for a recipe with the following ingredients: \(ingredients.joined(separator: ", "))."
        
        if #available(iOS 18.0, *) {
            // TODO: Integrate with Apple Intelligence
            return ingredients
        } else {
            return ingredients
        }
    }
    
    @available(iOS 18.0, *)
    private func generateWithAppleIntelligence(prompt: String, ingredients: [String]) async -> String? {
        // TODO: Integrate Apple Intelligence framework when available
        /*
        do {
            let model = AIModel.foundation
            let response = try await model.generate(prompt: prompt)
            return response.text
        } catch {
            return getFallbackRecipe(ingredients: ingredients)
        }
        */
        return getFallbackRecipe(ingredients: ingredients)
    }
    
    private func getFallbackRecipe(ingredients: [String]) -> String {
        let ingredientsList = ingredients.enumerated().map { "\($0.offset + 1). \($0.element)" }.joined(separator: "\n")
        let mainIngredients = ingredients.prefix(3).joined(separator: ", ")
        
        return """
        [Fallback] Simple Recipe

        Ingredients:
        \(ingredientsList)

        Instructions:
        1. Preheat your oven to 350°F (175°C).
        2. In a large bowl, combine the following ingredients: \(mainIngredients).
        3. Mix well until everything is evenly distributed.
        4. Transfer the mixture to a baking dish and bake for 25-30 minutes.
        5. Let it cool for a few minutes before serving.

        Cooking Time: ~45 minutes
        Servings: 2
        Difficulty: Easy

        Generated by a fallback mechanism.
        """
    }
    
    func analyzeRecipeImage(_ image: UIImage) async -> String? {
        guard isAIAvailable() else { return nil }
        
        if #available(iOS 18.0, *) {
            return await analyzeImageWithAppleIntelligence(image)
        }
        
        return "[Fallback] Detected: tomatoes, onions, garlic, herbs"
    }
    
    @available(iOS 18.0, *)
    private func analyzeImageWithAppleIntelligence(_ image: UIImage) async -> String? {
        // TODO: Integrate Apple Intelligence vision capabilities
        return "[Fallback] Detected ingredients from image"
    }
    
    func generateCookingInstructions(recipeName: String) async -> [String]? {
        guard isAIAvailable(), !recipeName.isEmpty else { return nil }
        
        let cacheKey = "instructions_\(recipeName)"
        if let cached = getCached(key: cacheKey), !cached.isEmpty {
            return cached.components(separatedBy: "\n").filter { !$0.isEmpty }
        }
        
        let prompt = "Generate step-by-step cooking instructions for: \(recipeName)"
        
        let result: [String]?
        if #available(iOS 18.0, *) {
            result = await generateInstructionsWithAI(prompt: prompt)
        } else {
            result = getDefaultInstructions()
        }
        
        if let result = result {
            setCached(key: cacheKey, value: result.joined(separator: "\n"))
        }
        
        return result
    }
    
    @available(iOS 18.0, *)
    private func generateInstructionsWithAI(prompt: String) async -> [String]? {
        // TODO: Integrate Apple Intelligence
        return getDefaultInstructions()
    }
    
    private func getDefaultInstructions() -> [String] {
        return [
            "[Fallback] Prepare and measure all ingredients",
            "Heat cooking vessel to appropriate temperature",
            "Combine ingredients following recipe order",
            "Cook until desired consistency achieved",
            "Season to taste and serve"
        ]
    }
    
    func suggestSubstitutions(ingredient: String) async -> [String]? {
        guard isAIAvailable(), !ingredient.isEmpty else { return nil }
        
        let cacheKey = "substitutions_\(ingredient)"
        if let cached = getCached(key: cacheKey), !cached.isEmpty {
            return cached.components(separatedBy: "\n").filter { !$0.isEmpty }
        }
        
        let prompt = "Suggest 3 substitutions for: \(ingredient)"
        
        let result: [String]?
        if #available(iOS 18.0, *) {
            result = await generateSubstitutionsWithAI(prompt: prompt, ingredient: ingredient)
        } else {
            result = getDefaultSubstitutions(ingredient: ingredient)
        }
        
        if let result = result {
            setCached(key: cacheKey, value: result.joined(separator: "\n"))
        }
        
        return result
    }
    
    @available(iOS 18.0, *)
    private func generateSubstitutionsWithAI(prompt: String, ingredient: String) async -> [String]? {
        // TODO: Integrate Apple Intelligence
        return getDefaultSubstitutions(ingredient: ingredient)
    }
    
    private func getDefaultSubstitutions(ingredient: String) -> [String] {
        // A simple dictionary for common substitutions
        let substitutionMap = [
            "butter": ["margarine", "coconut oil", "olive oil"],
            "sugar": ["honey", "maple syrup", "agave nectar"],
            "flour": ["almond flour", "coconut flour", "oat flour"],
            "milk": ["almond milk", "soy milk", "oat milk"],
            "egg": ["flax egg", "chia egg", "applesauce"]
        ]
        
        if let substitutions = substitutionMap[ingredient.lowercased()] {
            return substitutions
        }
        
        return [
            "[Fallback] Similar ingredient with comparable properties",
            "Common pantry alternative",
            "Dietary-friendly substitute"
        ]
    }
    
    func summarizeRecipe(_ recipe: String) async -> String? {
        guard isAIAvailable(), !recipe.isEmpty else { return nil }
        
        if #available(iOS 18.0, *) {
            return await summarizeWithAI(recipe: recipe)
        }
        
        return "Quick and easy recipe with simple ingredients"
    }
    
    @available(iOS 18.0, *)
    private func summarizeWithAI(recipe: String) async -> String? {
        // TODO: Integrate Apple Intelligence
        return "AI-generated summary"
    }
    
    private func getCached(key: String) -> String? {
        return cacheQueue.sync {
            cache[key]
        }
    }
    
    private func setCached(key: String, value: String) {
        cacheQueue.async { [weak self] in
            self?.cache[key] = value
            if (self?.cache.count ?? 0) > 50 {
                self?.cache.removeAll()
            }
        }
    }
    
    func clearCache() {
        cacheQueue.async { [weak self] in
            self?.cache.removeAll()
        }
    }
}
